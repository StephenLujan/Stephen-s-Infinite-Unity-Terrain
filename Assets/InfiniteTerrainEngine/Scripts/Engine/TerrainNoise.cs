

using System;
using System.Threading;
using UnityEngine;
using Debug = UnityEngine.Debug;
using Random = System.Random;

namespace StephenLujan.TerrainEngine
{
    /// <summary>
    /// Uses noises to generate heightmaps, detail maps, and texture alpha maps
    /// </summary>
    /// <remarks>
    /// Unity heightmaps are y,x indexed, even though it is inconsistent with everything else.
    /// </remarks>
    public class TerrainNoise : MonoBehaviour
    {
        [Tooltip("Use a seed number to consistently recreate terrain or set to 0 for a random seed.")]
        public int RandomSeed = 0;

        [Tooltip("Noise used to produce the terrain heightmaps.")]
        public UnityNoiseBase HeightNoise;
        public int HeightNoiseSampleScale = 1;

        [Tooltip("Noise used to produce the terrain details such as grass.")]
        public UnityNoiseBase DetailNoise;
        public int DetailNoiseSampleScale = 2;

        /// <summary>
        /// The Max value to which detail amounts are scaled
        /// </summary>
        [Range(1, 255)]
        [Tooltip("The Max value to which detail amounts are scaled.")]
        public float MaxDetail = 20;

        /// <summary>
        /// The minimum value below which a detail will not be shown
        /// </summary>
        [Range(1, 255)]
        [Tooltip("The minimum value below which a detail will not be shown.")]
        public float MinDetail = 5;

        /// <summary>
        /// transforms the range of values to exactly the range [0,1]
        /// Do not use if multiple unity terrains may be stitched together
        /// </summary>
        [Tooltip("Transforms the range of values to exactly the range [0,1]. Do not use with default behavior where multiple unity terrains are be stitched together.")]
        public bool TrueNormalize = false;

        /// <summary>
        /// Expected minimum of noise, used when Normalize is off
        /// </summary>
        [Tooltip("Expected minimum of noise coming from HeightNoise used to transform to the range of [0,1]. Values outside this range get flattened.")]
        public float TransformMin = -1.02f;

        /// <summary>
        /// Expected maximum of noise, used when Normalize is off
        /// </summary>
        [Tooltip("Expected maximum of noise coming from HeightNoise used to transform to the range of [0,1]. Values outside this range get flattened.")]
        public float TransformMax = 1.02f;

        /// <summary>
        /// adjust the height produced from the noise so that some altitudes are flatter and others steeper
        /// </summary>
        [Tooltip("adjust the height produced from the noise so that some altitudes are flatter and others steeper.")]
        public AnimationCurve HeightAdjustCurve;

        /// <summary>
        /// Calculate the minimum and maximum height coming out of HeightNoise before it is transformed to [0,1] range.
        /// </summary>
        [Tooltip("Calculate the minimum and maximum height coming out of HeightNoise before it is transformed to [0,1] range. Displayed below. Use this to recalibrate your values for TransformMin and TransformMax.")]
        public bool ShowRange = true;

        /// <summary>
        /// The maximum height generated by HeightNoise
        /// </summary>
        [Tooltip("The maximum height generated by HeightNoise")]
        [ReadOnly] public float HeightMax = float.NaN;

        /// <summary>
        /// The minimum height generated by HeightNoise
        /// </summary>
        [Tooltip("The minimum height generated by HeightNoise")]
        [ReadOnly] public float HeightMin = float.NaN;

        Random random;


        // Use this for initialization
        public void Start()
        {
            if (RandomSeed == 0)
            {
                random = new Random(unchecked((int)DateTime.Now.Ticks));
            }
            else
            {
                random = new Random(RandomSeed);
            }
            //Debug.Log(Thread.CurrentThread.ManagedThreadId);

            foreach (UnityNoiseBase noise in new UnityNoiseBase[] { HeightNoise, DetailNoise })
            {
                if (noise != null)
                {
                    noise.GetNoise().SetSeed(random.Next());
                }
                else
                {
                    Debug.LogError("One of the noise generators is not set in TerrainNoise.");
                }
            }

            HeightMin = float.PositiveInfinity;
            HeightMax = float.NegativeInfinity;
        }

        public void FillHeightMapNoise(int xStart, int yStart, float[,] heights)
        {
            Debug.Log($"FillHeightMapNoise({xStart}, {yStart}) on thread {Thread.CurrentThread.ManagedThreadId}");
            int mapWidth = heights.GetUpperBound(1) + 1;
            int mapHeight = heights.GetUpperBound(0) + 1;

            HeightNoise.GetNoise().GetNoiseSet(xStart, yStart, ref heights, true);
            float min = float.PositiveInfinity;
            float max = float.NegativeInfinity;
            float currentHeight = 0;

            for (int x = 0; x < mapWidth; x++)
            {
                for (int y = 0; y < mapHeight; y++)
                {
                    if (TrueNormalize || ShowRange)
                    {
                        currentHeight = heights[y, x];
                        min = Mathf.Min(min, currentHeight);
                        max = Mathf.Max(max, currentHeight);
                    }
                }
            }

            HeightMax = Mathf.Max(HeightMax, max);
            HeightMin = Mathf.Min(HeightMin, min);

            float normalizationMultiplier = TrueNormalize ? 1.0f / (max - min) : 1.0f / (TransformMax - TransformMin);
            Debug.Log($"TransformMin: {TransformMin}");
            Debug.Log($"normalizationMultiplier: {normalizationMultiplier}");

            for (int x = 0; x < mapWidth; x++)
            {
                for (int y = 0; y < mapHeight; y++)
                {
                    currentHeight = heights[y, x];

                    if (TrueNormalize)
                    {
                        // normalize
                        currentHeight -= min;
                        currentHeight *= normalizationMultiplier;
                    }
                    else
                    {
                        // approximate normalization with preset values
                        currentHeight -= TransformMin;
                        currentHeight *= normalizationMultiplier;
                    }

                    // exponentiate to exaggerate high terrain and flatten low terrain
                    //current = Mathf.Pow(current, Exponent);
                    currentHeight = HeightAdjustCurve.Evaluate(currentHeight);

                    heights[y, x] = currentHeight;
                }
            }

            if (!TrueNormalize && ShowRange)
            {
                if ((max - TransformMin) * normalizationMultiplier > 1.0f)
                {
                    Debug.LogAssertion("max value exceeded 1.0");
                }
                if ((min - TransformMin) * normalizationMultiplier < 0f)
                {
                    Debug.LogAssertion("min value below 0");
                }
                //Debug.Log($"min before normalization: {min}");
                //Debug.Log($"max before normalization: {max}");
            }
        }

        public void PopulateDetails(int xStart, int yStart, ref int[,] detailMap, float[,] heightMap, int layer)
        {
            Debug.Log($"PopulateDetails({xStart}, {yStart}) on thread {Thread.CurrentThread.ManagedThreadId}");
            // offset noise differently for plant species to avoid identical distributions
            int offset = layer * 111;
            int width = detailMap.GetUpperBound(0) + 1;
            int height = detailMap.GetUpperBound(1) + 1;
            float[,] noise = new float[width, height];
            //DetailNoise.GetNoise().GetSampledNoiseSet(xStart + offset, yStart + offset, DetailNoiseSampleScale, ref noise);
            DetailNoise.GetNoise().GetNoiseSet(xStart + offset, yStart + offset, ref noise);

            for (int x = 0; x < width; x++)
            {
                for (int y = 0; y < height; y++)
                {
                    // roughly remap noise values to [0,1] 
                    float outputNoise = (1.0f + noise[x, y]) / 1.0f;
                    // exaggerate noise by squaring
                    outputNoise = Mathf.Pow(outputNoise, 2.0f);
                    // scale to detail map range [0, 255?]
                    detailMap[x, y] = (int)(outputNoise * MaxDetail);
                    if (detailMap[x, y] < MinDetail)
                    {
                        detailMap[x, y] = 0;
                    }
                }
            }
            //Debug.Log($"Layer: {layer} noise max:{noise.Max()}");
            //Debug.Log($"Layer: {layer} noise min:{noise.Min()}");
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="settings"></param>
        /// <param name="alphaMaps"></param>
        /// <param name="heightMap"></param>
        /// <param name="slopeMap"></param>
        public static void AddAlphaNoise(TextureSplatSettings[] settings, float[,,] alphaMaps, float[,] heightMap, float[,] slopeMap, float textureBlendSharpness)
        {
            Debug.Log($"AddAlphaNoise() on thread {Thread.CurrentThread.ManagedThreadId}");
            //TODO the settings currently have to match up in length and order with alphaMaps but nothing is doing that
            int mapWidth = heightMap.GetUpperBound(1) + 1;
            int mapHeight = heightMap.GetUpperBound(0) + 1;
            int numMaps = alphaMaps.GetUpperBound(2) + 1;
            int alphaMapWidth = alphaMaps.GetUpperBound(0) + 1;
            int alphaMapHeight = alphaMaps.GetUpperBound(1) + 1;

            float heightMapWidthOverAlphaMapWidth = mapWidth / (float)alphaMapWidth;
            float heightMapHeightOverAlphaMapHeight = mapHeight / (float)alphaMapHeight;

            float[] textureWeights = new float[numMaps];
            TextureSplatSettings currentSettings;

            for (int y = 0; y < alphaMapHeight; y++)
            {
                for (int x = 0; x < alphaMapWidth; x++)
                {
                    int heightMapX = (int)(x * heightMapWidthOverAlphaMapWidth);
                    int heightMapY = (int)(y * heightMapHeightOverAlphaMapHeight);
                    // Yes height and slope are y, x indexed. Blame Unity.
                    float height = heightMap[heightMapY, heightMapX];
                    float slope = slopeMap[heightMapY, heightMapX];
                    float combinedWeight = 0;

                    for (int tex = 0; tex < numMaps; tex++)
                    {
                        currentSettings = settings[tex];
                        textureWeights[tex] = Mathf.Max(0, Mathf.Min(height - currentSettings.MinimumHeight, currentSettings.MaximumHeight - height));
                        textureWeights[tex] *= Mathf.Max(0, Mathf.Min(slope - currentSettings.MinimumSlope, currentSettings.MaximumSlope - slope));
                        textureWeights[tex] = Mathf.Pow(textureWeights[tex], textureBlendSharpness);
                        combinedWeight += textureWeights[tex];
                    }

                    Debug.Assert(combinedWeight != 0);
                    for (int tex = 0; tex < numMaps; tex++)
                    {
                        alphaMaps[y, x, tex] = textureWeights[tex] / combinedWeight;
                    }
                }
            }
        }
    }
}